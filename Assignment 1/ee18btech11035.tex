\documentclass[journal,12pt,twocolumn]{IEEEtran}

\usepackage{setspace}
\usepackage{gensymb}
\singlespacing
\usepackage[cmex10]{amsmath}

\usepackage{amsthm}

\usepackage{mathrsfs}
\usepackage{txfonts}
\usepackage{stfloats}
\usepackage{bm}
\usepackage{cite}
\usepackage{cases}
\usepackage{subfig}

\usepackage{longtable}
\usepackage{multirow}

\usepackage{enumitem}
\usepackage{mathtools}
%\usepackage{steinmetz}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{verbatim}
%\usepackage{tfrupee}
\usepackage[breaklinks=true]{hyperref}
\usepackage{graphicx}
\usepackage{tkz-euclide}

\usetikzlibrary{calc,math}
\usepackage{listings}
    \usepackage{color}                                            %%
    \usepackage{array}                                            %%
    \usepackage{longtable}                                        %%
    \usepackage{calc}                                             %%
    \usepackage{multirow}                                         %%
    \usepackage{hhline}                                           %%
    \usepackage{ifthen}                                           %%
    \usepackage{lscape}     
\usepackage{multicol}
\usepackage{chngcntr}

\DeclareMathOperator*{\Res}{Res}

\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}


\hyphenation{op-tical net-works semi-conduc-tor}
\def\inputGnumericTable{}                                 %%

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}
\begin{document}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{definition}[problem]{Definition}

\newcommand{\BEQA}{\begin{eqnarray}}
\newcommand{\EEQA}{\end{eqnarray}}
\newcommand{\define}{\stackrel{\triangle}{=}}
\bibliographystyle{IEEEtran}
\raggedbottom
\setlength{\parindent}{0pt}
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
% \providecommand{\abs}[1]{\left\vert#1\right\vert}
% \providecommand{\res}[1]{\Res\displaylimits_{#1}} 
% \providecommand{\norm}[1]{\left\lVert#1\right\rVert}
% %\providecommand{\norm}[1]{\lVert#1\rVert}
% \providecommand{\mtx}[1]{\mathbf{#1}}
% \providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
%\providecommand{\hilbert}{\overset{\mathcal{H}}{ \rightleftharpoons}}
\providecommand{\system}{\overset{\mathcal{H}}{ \longleftrightarrow}}
	%\newcommand{\solution}[2]{\textbf{Solution:}{#1}}
\newcommand{\solution}{\noindent \textbf{Solution: }}
\newcommand{\cosec}{\,\text{cosec}\,}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\numberwithin{equation}{subsection}
\makeatletter
\@addtoreset{figure}{problem}
\makeatother
\let\StandardTheFigure\thefigure
\let\vec\mathbf
\renewcommand{\thefigure}{\theproblem}
\def\putbox#1#2#3{\makebox[0in][l]{\makebox[#1][l]{}\raisebox{\baselineskip}[0in][0in]{\raisebox{#2}[0in][0in]{#3}}}}
     \def\rightbox#1{\makebox[0in][r]{#1}}
     \def\centbox#1{\makebox[0in]{#1}}
     \def\topbox#1{\raisebox{-\baselineskip}[0in][0in]{#1}}
     \def\midbox#1{\raisebox{-0.5\baselineskip}[0in][0in]{#1}}
\vspace{3cm}
\title{Assignment 1}
\author{P Aashrith - EE18BTECH11035}
\maketitle
\newpage
\bigskip
\renewcommand{\thefigure}{\theenumi}
\renewcommand{\thetable}{\theenumi}
Download all Codes from 
%
\begin{lstlisting}
https://github.com/Aashrith20/C-and-DS/tree/main/Assignment%201/codes
\end{lstlisting}
Download all latex-tikz codes from 
\begin{lstlisting}
https://github.com/Aashrith20/C-and-DS/blob/main/Assignment%201/ee18btech11035.tex
\end{lstlisting}
\section{Problem}
Consider a Sequence of 14 elements: A = [-5,-10,6,3,-1,-2,13,4,-9,-1,4,12,-3,0]. The subsequence sum  $ S(i,j) =  \sum_{k=i}^{j} A[$k$]$ . Determine the maximum of $S(i,j)$, where $0\leq i\leq j < 14$. (Divide and Conquer approach may be used)
\section{Solution}
C Code can found in the following directory
\begin{lstlisting}
https://github.com/Aashrith20/C-and-DS/blob/main/Assignment%201/codes/code.c
\end{lstlisting}
\textbf{By Divide and Conquer :}\\
Calculate mid index of array which is $(start+end)/2$ \\
Then recursively call the function to solve the left and right subarray.\\
\\
For left subarray start index is the same as previous start index but end index is mid.At each recursive call Store the returned value in a variable \textbf{LeftSubArrayMax}  .\\
\\
In the case of right subarray start index is $(mid+1)$ index but end index is the same as previous end index.At each recursive call Store the returned value in a variable \textbf{RightSubArrayMax}.\\
\\
Calculating the maximum subsequence sum of whole array:\\
\textbf{Step 1:}\\
Calculate the maximum of subsequence sum of all the subarrays in the left subarray with ending index as mid.

\begin{align}
    left_{sum} = max(S(i,mid)) \forall \brak{start \le i \le mid }    
\end{align}\\

\textbf{Step 2:}\\
Calculate the maximum subsequence sum sum of all the subarrays in the right subarray with starting index as mid+1.
\begin{align}
    right_{sum} = max(S(mid+1,i))  \forall \brak{mid+1 \le i \le end }
\end{align}

Calculate the $left_{sum}$ and $right_{sum}$ at each recursion call.\\
To get the maximum subsequence sum return $max(LeftSubArrayMax,RightSubArrayMax,left_{sum}+right_{sum})$ 

\begin{figure}[!ht]
    \begin{center}
		\resizebox{\columnwidth}{!}{\input{./figs/figure.tex}}
	\end{center}
\caption{}
\label{fig:ee18btech11035_block}
\end{figure}

Answer for this particular array is 29.

\section{Vector Representation}

$S(i,j)$ represents the sum of all elements of array from index i to j.\\

Let x be a vector defined as \\
\newcommand{\block}[1]{
  \underbrace{1 \cdots 1}_{#1}
}
\begin{align}
    \underline{x} = 
    \begin{pmatrix}
    0 & 0 & 0 & \smash[b]{\block{\text{from index i to j}}} & 0 & 0 & 0
    \end{pmatrix}
\end{align}\\

$S(i,j)$ can be rewritten in the vector representation as follows \\
\begin{align}
     S(i,j) &=  \sum_{k=i}^{j} A[k] \\
     S(i,j) &= A\underline{x}^{T}
\end{align}

\section{Time Complexity}
\begin{align}
    T\brak{N} = 2T\brak{N/2} + O\brak{N} \\
    \label{eq:e1}
    T\brak{N} = 2T\brak{N/2} + cN \\
    \label{eq:e2}
    T\brak{N/2} = 2T\brak{N/4} + cN/2
\end{align}
Substituting \eqref{eq:e2} in \eqref{eq:e1}
\begin{align}
    T\brak{N} &= 2\sbrak{2T\brak{N/4}+c\brak{N/2}} + cN \\
    T\brak{N} &= 4T\brak{N/4} + 2cN \\
    \text{Similarly, }T\brak{N} &= 8T\brak{N/8} + 3cN \\
    \text{In general }T\brak{N}&=2^k T\brak{N/2^k} + kcN 
    \label{eq:e3}
\end{align}
Upper limit of K occurs when :
\begin{align}
    N/2^k =& 1\\
    2^k =& N \\
    k =& \log{N}
\end{align}
Assuming T\brak{1} = 1 \\
Solving \eqref{eq:e3} by Substituting $k =\log{N}$ \\
\begin{align}
    T\brak{N}=2^k T\brak{N/2^k} + kcN\\
    T\brak{N}=N T\brak{1} + cN\log{N} \\
    T\brak{N}=N+cN\log{N}
\end{align}
\begin{align}
    T\brak{N} \approx O\brak{\text{NlogN}}
\end{align}


\section{Optimization}
C Code can found in the following directory
\begin{lstlisting}
https://github.com/Aashrith20/C-and-DS/blob/main/Assignment%201/codes/optimized_code.c
\end{lstlisting}

Initialize 2 variables \textbf{GlobalMax} and \textbf{LocalMax} with $-\infty$ \\

While iterating the array If the LocalMax is positive continue the same subarray by adding element at that index to the LocalMax else begin a new subarray by updating the LocalMax to element at that index.\\

\begin{lstlisting}
if(LocalMax<0)
{
    LocalMax = arr[i];
}
else
{
    LocalMax = LocalMax + arr[i];
}
\end{lstlisting}

At each iteration update the GlobalMax.\\
\begin{lstlisting}
GlobalMax = max(GlobalMax,LocalMax);
\end{lstlisting}

Finally, return the GlobalMax.

\section{Complexities}

\textbf{Time Complexity :} Iteration is done N times 
\begin{align}
    \text{So, }T\brak{N} = O\brak{N}
\end{align}

\textbf{Space Complexity :}
\begin{align}
    S\brak{N} = O\brak{1}
\end{align}
\end{document}